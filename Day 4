Problem solving on coding:
Problems are solved in C++

1. Given a positive integer value N. The task is to find how many numbers less than or equal to N have numbers of divisors exactly equal to 3.

Example 1:

Input:
N = 6
Output: 1
Explanation: The only number with 
3 divisor is 4.
Expected Time Complexity : O(N1/2 * N1/4)
Expected Auxilliary Space :  O(1)

My Solution:

bool isPrime(int n){
if(n<=1)
return false;
else if(n<=3)
return true;
else if(n%2==0 || n%3==0)
return false;
else{
for(int i=5;i*i<=n;i+=6){
if(n%(i)==0 || n%(i+2)==0)
return false;
}
return true;
}
}
int exactly3Divisors(int N)
{
int a=3,c=0;
for(int i=4;i<=N;i+=a){
if(isPrime(sqrt(i))==true)
c++;
a+=2;
}
return c;
}

2. You are given two numbers a and b. You need to find the sum of a and b under modulo M (M = 109+7)

Example 1:

Input:
a = 9223372036854775807
b = 9223372036854775807
Output: 582344006
Explanation: 9223372036854775807 +
9223372036854775807 = 
18446744073709551614.
Now do (18446744073709551614) mod (109+7)
= 582344006
Expected Time Complexity : O(1)
Expected Auxilliary Space :  O(1)

My solution:

int sumUnderModulo(long long a,long long b)
{
    int M=1000000007;
    //your code here
    return(a%M+b%M)%M;
}

3. Given two integers ‘a’ and ‘m’. The task is to find modular multiplicative inverse of ‘a’ under modulo ‘m’.
Note: Print the smallest modular multiplicative inverse.

Example 1:

Input:
a = 3
m = 11
Output: 4
Explanation: Since (4*3) mod 11 = 1, 4 
is modulo inverse of 3. One might think,
15 also as a valid output as "(15*3)
mod 11"  is also 1, but 15 is not in 
ring {0, 1, 2, ... 10}, so not valid.
Expected Time Complexity : O(m)
Expected Auxilliary Space : O(1)

My solution:

int modInverse(int a, int m)
{
    //Your code here
     a = a % m;
    for(int i = 1; i< m; i++)
    if((a*i) % m == 1)
    {
        return i; 
    }
    return -1;
}

4.For a given number N check if it is prime or not. A prime number is a number which is only divisible by 1 and itself.

Example 1:

Input:
N = 5
Output: Yes
Explanation: 5 is a prime number.
Expected Time Complexity : O(N^1/2)
Expected Auxilliary Space :  O(1)

bool isPrime(int n)
{
    //Your code here
    if (n==1)
    return false;
    if (n==2||n==3)
    return true;
    if(n%2==0||n%3==0)
    return false;
    for(int i=5;i*i<=n;i=i+6)
        if(n%i==0||n%(i+2)==0)
            return false;
    return true;
}

All my solutions passed the test cases.

