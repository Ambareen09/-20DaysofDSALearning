Problem 1
Given an unsorted array of N elements and an element X. The task is to write a recursive function to check whether the element X is present in the given array or not.

Example:
array[] = {1, 2, 3, 4, 5}
X = 3.

The function should return True, as 3 is 
present in the array.

The recursive function will somewhat look like as shown below:
// arr[] is the given array 
// l is the lower bound in the array
// r is the upper bound
// x is the element to be searched for
// l and r defines that search will be 
// performed between indices l to r

bool recursiveSearch(int arr[], int l,  
                            int r, int x) 
{ 
    if (r < l) 
        return false; 
    if (arr[l] == x) 
        return true; 
    if (arr[r] == x) 
        return true; 

    return recursiveSearch(arr, l + 1,  
                              r - 1, x); 
} 

Time Complexity: The above algorithm runs in O(N) time where, N is the number of elements present in the array.
Space Complexity: There is no extra space used however the internal stack takes O(N) extra space for recursive calls.

Problem 2
Given a string, the task is to write a recursive function to check if the given string is palindrome or not.

Examples:
Input : string = "malayalam"
Output : Yes
Reverse of malayalam is also
malayalam.

Input : string = "max"
Output : No
Reverse of max is not max.


Solution: The idea to write the recursive function is simple and similar to the above problem:
If there is only one character in string, return true.
Else compare first and last characters and recur for remaining substring.

Recursive Function:
// s and e defines the start and end index of string

bool isPalindrome(char str[], int s, int e) 
{ 
    // If there is only one character 
    if (s == e) 
        return true; 
  
    // If first and last 
    // characters do not match 
    if (str[s] != str[e]) 
        return false; 
  
    // If there are more than  
    // two characters, check if  
    // middle substring is also  
    // palindrome or not
    if (s < e) 
        return isPalindrome(str, s + 1, e - 1); 
  
    return true; 
} 

Tail Recursion: A recursive function is said to be following Tail Recursion if it invokes itself at the end of the function. That is, if all of the statements are executed before the function invokes itself then it is said to be following Tail Recursion.

Which one is Better-Tail Recursive or Non Tail-Recursive?

The tail-recursive functions are considered better than non-tail recursive functions as tail-recursion can be optimized by compiler. The idea used by compilers to optimize tail-recursive functions is simple, since the recursive call is the last statement, there is nothing left to do in the current function, so saving the current functionâ€™s stack frame is of no use.


Can a non-tail recursive function be written as tail-recursive to optimize it?

Consider the following function to calculate factorial of N. It is a non-tail-recursive function. Although it looks like a tail recursive at first look. If we take a closer look, we can see that the value returned by fact(N-1) is used in fact(N), so the call to fact(N-1) is not the last thing done by fact(N).

int fact(int N) 
{ 
    if (N == 0) 
        return 1; 
  
    return N*fact(N-1); 
} 

The above function can be written as a tail recursive function. The idea is to use one more argument and accumulate the factorial value in second argument. When N reaches 0, return the accumulated value.
int factTR(int N, int a) 
{ 
    if (N == 0)  
        return a; 
  
    return factTR(N-1, N*a); 
} 
