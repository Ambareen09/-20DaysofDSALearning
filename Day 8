1. Sum of Natural nos using recursion:

int getsum(int n)
{
  if(n==0)
  return 0;
  return n+getsum(n-1);
}

T(n)=T(n-1)+ theta(1);
Auxillary space: theta(n);


2. Palindrome check using recursion:

#include <iostream>
using namespace std;


bool isPalindrome(string str, int start, int end)
{
	if(start >= end)
		return true;

	return ((str[start]==str[end]) && 
		     isPalindrome(str, start + 1, end - 1));
}

int main() {
	
	string s = "GeekskeeG";
	
		printf("%s", isPalindrome(s, 0, s.length() -1) ? "true" : "false");
	
	return 0;
}

T(n)= T(n-2)+theta(1) or O(n)
Aux space: O(n)


3. Sum of digits using recursion:

int sums(int n)
{
if(n<0)
return n;
return sums(n/10)+ n%10;
}



4. Subset of Strings:

#include <iostream>
using namespace std;


void printSub(string str, string curr, int index)
{
	if(index == str.length())
	{
		cout<<curr<<" ";
		return;
	}

	printSub(str, curr, index + 1);
	printSub(str, curr+str[index], index + 1);
}
	
int main() {
	
	string str = "ABC";
    	
    printSub(str, "", 0);
	
	return 0;
}


5. Given a rope lenght n, you need to find max no. of pieces you can make such that length of every piece is in set {a,b,c} for given 3 values of a,b,c.

#include <iostream>
using namespace std;


int maxCuts(int n, int a, int b, int c)
{
	if(n == 0)
		return 0;
	if(n <= -1)
		return -1;

	int res = max(maxCuts(n-a, a, b, c), 
	          max(maxCuts(n-b, a, b, c), 
	          maxCuts(n-c, a, b, c)));

	if(res == -1)
		return -1;

	return res + 1; 
}
int main() {
	
	int n = 5, a = 2, b = 1, c = 5;
	
	cout<<maxCuts(n, a, b, c);
	
	return 0;
}

Time complexity: 3^n

6. TOWER OF HANOI:
Concept: Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
1) Only one disk can be moved at a time.
2) Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
3) No disk may be placed on top of a smaller disk.

Take an example for 2 disks :
Let rod 1 = 'A', rod 2 = 'B', rod 3 = 'C'.

Step 1 : Shift first disk from 'A' to 'B'.
Step 2 : Shift second disk from 'A' to 'C'.
Step 3 : Shift first disk from 'B' to 'C'.

The pattern here is :
Shift 'n-1' disks from 'A' to 'B'.
Shift last disk from 'A' to 'C'.
Shift 'n-1' disks from 'B' to 'C'.

void towerOfHanoi(int n, char from_rod, 
                    char to_rod, char aux_rod)  
{  
    if (n == 1)  
    {  
        cout << "Move disk 1 from rod " << from_rod <<  
                            " to rod " << to_rod<<endl;  
        return;  
    }  
    towerOfHanoi(n - 1, from_rod, aux_rod, to_rod);  
    cout << "Move disk " << n << " from rod " << from_rod << 
                                " to rod " << to_rod << endl;  
    towerOfHanoi(n - 1, aux_rod, to_rod, from_rod);  
}  

T(n)= 2T(n-1) +1



7. JOSEPHUS PROBLEM:
Concept: There are n people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. Given the total number of persons n and a number k which indicates that k-1 persons are skipped and kth person is killed in circle. The task is to choose the place in the initial circle so that you are the last one remaining and so survive.


For example, if n = 5 and k = 2, then the safe position is 3. Firstly, the person at position 2 is killed, then person at position 4 is killed, then person at position 1 is killed. Finally, the person at position 5 is killed. So the person at position 3 survives.
If n = 7 and k = 3, then the safe position is 4. The persons at positions 3, 6, 2, 7, 5, 1 are killed in order, and person at position 4 survives.

int josephus(int n, int k)
{
  if (n == 1)
    return 1;
  else
    /* The position returned by josephus(n - 1, k) 
       is adjusted because the recursive call 
       josephus(n - 1, k) considers the original 
       position k%n + 1 as position 1 */
    return (josephus(n - 1, k) + k-1) % n + 1;
}


8. Subset Sum Problem:
Given a set of non-negative integers, and a value sum, determine how many subset of the given set with sum equal to given sum.

int count( int arr[], int n, int sum)
{
  if (n==0)
  return (sum==0)?1:0;
  return count(arr, n-1, sum) + count(arr,n-1,sum-arr[n-1]);
}

T(n)= 2^n + (2^n-1)
    = theta(2^n)
