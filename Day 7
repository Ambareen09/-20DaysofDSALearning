Today I solved more problems using Bitwise Operations.
I also started Recusrsive functions.

1.Given a number N. The task is to find the length of the longest consecutive 1s in its binary representation.

Example 1:

Input: N = 14
Output: 3
Explanation: Binary representation of 14 is 
1110, in which 111 is the longest consecutive 
set bits of length is 3.

int maxConsecutiveOnes(int n)
{
 
    // Your code here
    int c=0;
    while(n!=0)
    {
        n=(n&(n<<1));
        c++;
    }
    return c;
    
}


2.You are given a decimal number N. You need to find the gray code of the number N and convert it into decimal.
Binary to Gray conversion :

The Most Significant Bit (MSB) of the gray code is always equal to the MSB of the given binary code.
Other bits of the output gray code can be obtained by XORing binary code bit at that index and previous index.


Example 1:

Input: N = 7
Output: 4
Explanation: 7 is represented as 111 in 
binary form. The gray code of 111 is 100,

int greyConverter(int n)
{
    
    // Your code here
    return (n^(n>>1));
    
}


3.Given N in Gray code equivalent. Find its binary equivalent. 
Note: We need to find the binary equivalent of the given gray code and return the decimal equivalent of the binary representation.
Gray to binary conversion :

The Most Significant Bit (MSB) of the binary code is always equal to the MSB of the given binary number.
Other bits of the output binary code can be obtained by checking gray code bit at that index. If current gray code bit is 0, then copy previous binary code bit, else copy invert of previous binary code bit.

Example 1:

Input: N = 4
Output: 7
Explanation:
4 is represented as gray 100 and its 
binary equivalent is 111 whose decimal 
equivalent is 7.

int grayToBinary(int n)
{
    
    // Your code here
    int inv = 0; 
  
    // Taking xor until n becomes zero 
    for (; n; n = n >> 1) 
        inv ^= n; 
  
    return inv; 
    
}


4.Given a positive integer N. The task is to check if N is a power of 2. More formally, check if N can be expressed as 2x for some x.
 

Example 1:

Input: N = 1
Output: true
Explanation: 1 is equal to 2 raised to 0 (20 == 1).

bool isPowerofTwo(long long n)
{
    if (n==0)
    return false;
    return((n&(n-1))==0);
    
    
    // Your code here    
    
}


5. Given an unsigned integer N. The task is to swap all odd bits with even bits. For example, if the given number is 23 (00010111), it should be converted to 43(00101011). Here, every even position bit is swapped with adjacent bit on the right side(even position bits are highlighted in the binary representation of 23), and every odd position bit is swapped with an adjacent on the left side.

Example 1:

Input: N = 23
Output: 43
Explanation: 
Binary representation of the given number 
is 00010111 after swapping 
00101011 = 43 in decimal.

unsigned int swapBits(unsigned int x)
{
	
	// Your code here
	 unsigned int even_bits = x & 0xAAAAAAAA;  
  
    // Get all odd bits of x  
    unsigned int odd_bits = x & 0x55555555;  
  
    even_bits >>= 1; // Right shift even bits  
    odd_bits <<= 1; // Left shift odd bits  
  
    return (even_bits | odd_bits);
	
}

Recursion:

What is Recursion?

The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called as recursive function. Using recursive algorithm, certain problems can be solved quite easily. Examples of such problems are Towers of Hanoi (TOH), Inorder/Preorder/Postorder Tree Traversals, DFS of Graph, etc.
What is base condition in recursion?

In recursive program, the solution to base case is provided and solution of bigger problem is expressed in terms of smaller problems.
Why Stack Overflow error occurs in recursion? If base case is not reached or not defined, then stack overflow problem may arise.

Disadvantage of Recursion: Note that both recursive and iterative programs have same problem solving powers, i.e., every recursive program can be written iteratively and vice versa is also true. Recursive program has greater space requirements than iterative program as all functions will remain in stack until base case is reached. It also has greater time requirements because of function calls and return overhead.

Advantages of Recursion: Recursion provides a clean and simple way to write code. Some problems are inherently recursive like tree traversals, Tower of Hanoi, etc. For such problems it is preferred to write recursive code. We can write such codes also iteratively with the help of stack data structure.

